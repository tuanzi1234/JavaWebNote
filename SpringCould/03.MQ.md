### 一、异步调用
   通常基于消息通知的方式，包含三个角色:
   - 消息发送者: 投递消息，原来的调用者
   - 消息接收者: 接收消息，原来的服务提供者
   - 消息代理: 管理、暂存、转发消息
### 二、RabbitMQ
#### **1. 基于Docker安装**
   ```bash
   docker run \
   -e RABBITMQ_DEFAULT_USER=root \
   -e RABBITMQ_DEFAULT_PASS=123456 \
   -v mq-plugins:/plugins \
   --name mq \
   --hostname mq \
   -p 15672:15672 \
   -p 5672:5672 \
   --network hm-net\
   -d \
   rabbitmq:3.8-management
   ```
#### **2. RabbitMQ架构**
- **publisher**: 消息发送者
- **consumer**: 消息接收者
- **queue**: 队列, 存储消息
- **exchange**: 交换机, 负责路由消息
- **virtual-host**: 虚拟主机, 虚拟的队列和交换机, 虚拟主机之间互不干扰
  ![1758902242234](image/03.MQ/1758902242234.png)
#### **3. 使用RabbitMQ**
1. 引入依赖:
   ```xml
   <!-- AMQP依赖，包含RabbitMQ依赖 -->
   <dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-amqp</artifactId>
   </dependency>
   ```
2. 在每个微服务中引入MQ服务端信息:
   ```yaml
   spring:
      rabbitmq:
         host: 192.168.3.54 # 服务器地址
         port: 5672 # 端口
         virtual-host: / # 虚拟主机
         username: root # 用户名
         password: 123456 # 密码
   ```
3. 发送消息:
   ```java
   @Autowired
   private RabbitTemplate rabbitTemplate;

   @Test
   public void sendMessage() {
      // 队列名称
      String queueName = "queue.test";
      // 消息
      String message = "hello world";
      // 发送消息
      rabbitTemplate.convertAndSend(queueName, message);
   }
   ```
4. 接收消息:
   ```java
   @Slf4j
   @Component
   public class ReceiveMessageListener {
      @RabbitListener(queues = "queue.test")
      public void listenSimpleQueueMessage(String message) throws InterruptedException {
         log.info("接收到消息: {}", message);
      }
   }
   ```
#### **4. work Queues**
任务模型，让多个消费者绑定到一个队列，共同消费对列的消息。
![1758909193714](image/03.MQ/1758909193714.png)
默认情况下，RabbitMQ会将消息依次轮流投递给绑定在队列上的每一个消费者，但并没考虑到消费者是否处理完消息，可能出现消息堆积的情况。
解决方案：在application.yml中设置preFetch值为1，确保同一时刻最多投递给消费者一条信息:
```yaml
spring:
   rabbitmq:
      listener:
         simple:
            prefetch: 1 # 每次只处理一条消息，处理完成才能获取下一个消息
```
#### **5. Fanout交换机**
Fanout交换机会将接收到的消息广播给所有绑定的队列，每个队列都会收到相同的消息。
![1758911783996](image/03.MQ/1758911783996.png)
#### **6. Direct交换机**
Direct交换机会将接收到的消息根据规则路由到指定的Queue中, 因此被称之为定向路由
![1758911860569](image/03.MQ/1758911860569.png)
- 每一个Queue都与Exchange设置一个BindingKey
- 发布者发送消息时，会指定消息的RoutingKey
- Exchange将消息路由到BindingKey与消息RoutingKey一致的队列
#### **7. Topic交换机**
Topic交换机也是基于RoutingKey做消息路由，不过RoutingKey可以由多个单词组成，多个单词之间使用`.`分隔
![1758912645614](image/03.MQ/1758912645614.png)
#### **8. 基于Bean声明队列和交换机**
SpringAMQP提供了几个类用来声明队列、交换机、绑定关系:
- **Queue**: 用于声明队列，使用工厂类`QueueBuilder`创建
- **Exchange**: 用于声明交换机，使用工厂类`ExchangeBuilder`创建
- **Binding**: 用于绑定队列和交换机，使用工厂类`BindingBuilder`创建
例子:
```java
@Configuration
public class RabbitMQConfig { 
   // 声明anoutExchange交换机
   @Bean
   public FanoutExchange fanoutExchange() {
      return new FanoutExchange("hmall.fanout");
    }
    // 声明第一个队列
    @Bean
    public Queue fanoutQueue1() {
      return new Queue("fanout.queue1");
    }
    // 绑定队列1到交换机
    @Bean
    public Binding bindingQueue1(FanoutExchange fanoutExchange, Queue fanoutQueue1) {
      return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);
    }
    // 其他队列......
}
```
#### **9. 基于注解声明队列和交换机**
SpringAMQP提供了基于@RabbitListener注解来声明队列和交换机的方式:
```java
@RabbitListener(bindings = @QueueBinding(
   value = @Queue(name = "direct.queue1"), 
   exchange = @Exchange(name = "itcast.direct", type = ExchangeTypes.DIRECT),
   key = { "red", "green" }
   ))
public void listenDirectQueue1(String message) {
   log.info("消费者1接收到消息: {}", message);
}
```
#### **10. 消息转换器**
Spring的对消息对象的处理是由org.springframework.amqp.support.converter.MessageConverter处理的。
默认实现使用的是SimpleMessageConverter，是基于JDK的ObjectOutputStream完成序列化。
存在下列问题:
- JDK的序列化有安全风险
- JDK序列化的消息太大
- JDK序列化的消息可读性差
为了解决上面问题，一般会采用JSON序列化代替默认的JDK序列化:
1. 引入依赖:
```xml
<dependency>
<groupId>com.fasterxml.jackson.core</groupId>
<artifactId>jackson-databind</artifactId>
</dependency>
```
2. 在pushlisher和consumer中配置消息转换器:
```java
@Bean
public MessageConverter messageConverter() { 
   return new Jackson2JsonMessageConverter();
}
```
